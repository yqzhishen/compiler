# 词法分析实验报告

#### 姓名：杨迁		学号：19231120



## 1. NFA和DFA

由于保留字（关键字）的状态转移较为复杂，因此在这一步暂时将保留字视为标识符，后续再加以区分。

首先根据各Token的文法构造NFA，其状态转移函数如下：

| 状态 \ 符号 |         ε         | 数字 | 字母和下划线 |  =   | ;(){}+*/<> | 识别单词 |
| :---------: | :---------------: | :--: | :----------: | :--: | :--------: | :------: |
|      0      | {1, 3, 5, 7, ...} |  ∅   |      ∅       |  ∅   |     ∅      |    /     |
|      1      |         ∅         |  ∅   |     {2}      |  ∅   |     ∅      |    /     |
|      2      |         ∅         | {2}  |     {2}      |  ∅   |     ∅      | `Ident`  |
|      3      |         ∅         | {4}  |      ∅       |  ∅   |     ∅      |    /     |
|      4      |         ∅         | {4}  |      ∅       |  ∅   |     ∅      | `Number` |
|      5      |         ∅         |  ∅   |      ∅       | {6}  |     ∅      |    /     |
|      6      |         ∅         |  ∅   |      ∅       |  ∅   |     ∅      | `Assign` |
|      7      |         ∅         |  ∅   |      ∅       | {8}  |     ∅      |    /     |
|      8      |         ∅         |  ∅   |      ∅       | {9}  |     ∅      |    /     |
|      9      |         ∅         |  ∅   |      ∅       |  ∅   |     ∅      |   `Eq`   |
|     ...     |        ...        | ...  |     ...      | ...  |    ...     |   ...    |

将该NFA确定化为DFA，其状态转移函数如下：

| 状态 \ 符号 | 数字 | 字母和下划线 |  =   | ;(){}+*/<> | 识别单词 |
| :---------: | :--: | :----------: | :--: | :--------: | :------: |
|      0      |  2   |      1       |  3   |    ...     |    /     |
|      1      |  1   |      1       |  φ   |     φ      | `Ident`  |
|      2      |  2   |      φ       |  φ   |     φ      | `Number` |
|      3      |  φ   |      φ       |  4   |     φ      | `Assign` |
|      4      |  φ   |      φ       |  φ   |     φ      |   `Eq`   |
|     ...     | ...  |     ...      | ...  |    ...     |   ...    |



## 2. 几个主要的类（接口）

使用 Java 编写词法分析程序，主要包含以下几个主要的类。

### 2.1 Token 类

每个token均使用一个实例表示。

包含有枚举变量`type`，代表token类别；字符串`param`，代表该token的参数（`Ident`和`Number`类型的token需要参数）。重写了`toString()`方法，方便直接打印。

### 2.2 IState 接口

每个状态均使用一个实例表示。

接口中定义了方法`int recognize(char ch)`，当传入的字符为当前状态的可接收字符时，返回接收此字符后转移到的状态编号；若无法接收该字符，返回 -1。

为了避免反复实现该接口，增加了一个`SimpleState`类，用于定义那些只能接收一种字符或不能接收任何字符的简单状态。

### 2.3 Automaton 类

词法分析时用到的DFA也使用一个实例表示。

成员变量`IState[] states`，代表DFA的所有状态；成员变量`ArrayList<Character> contents`，存储DFA当前吃进的所有字符；成员变量`ArrayList<Integer> history`，存储DFA到达当前状态（含）所经过的所有状态。

方法`boolean push(char ch)`，判断字符`ch`是否可被当前状态接收，若可接收则吃进该字符，将转移后的状态编号添加到`history`末尾，返回`true`；若无法接收则返回`false`。

方法`char pop()`，从DFA中退出一个字符，并从`history`中移除最后一个状态。

方法`Token getToken()`从DFA中取出token。若当前状态为结束状态，则返回该状态下识别到的token，若为`Ident`或`Number`，则将`contents`拼合为字符串作为参数；否则返回`null`。

方法`void reset()`，清空DFA，将状态重置为初始状态。



## 3. 主程序

### 3.1 建立输入流

使用一个`PushbackReader`字符流来处理输入数据，当读入的字符无法被接受时可以使用`unread()`方法将其退回流中。

### 3.2 程序主循环

循环读入字符，直到读完输入数据。读入的字符主要有以下几种情况：

#### 3.2.1 空白符和文件尾

判断DFA中是否已经有吃进的字符，若已有字符，则判断能否取出合法的token，若能取出则打印token，并重置DFA，若不能取出则报错；若无字符则不做任何动作（应当支持跳过任意个空白符）。

#### 3.2.2 可被接受的字符

若读入的字符能被当前状态的DFA接受，则让DFA吃进该字符。因为要遵循最长匹配原则，因此直到出现无法接受的字符或文件尾之前，DFA都要循环吃进字符。

#### 3.2.3 不可被接受的字符

若读入了当前状态下不可接受的字符，则首先将该字符退回流中。然后判断是否能从DFA中取出合法token，若不能则从DFA中退出一个字符并退回流中，若能则打印该token；循环直到DFA为空，若直至DFA为空依然不能取出合法token则报错。

注：处理标识符`Ident`时，均先判断其是否为保留字，再进行打印操作。