# Lab 2 实验报告

#### 姓名：杨迁		学号：19231120



## 1. 表达式语法树的构建

由于需要同时支持正负号和四则运算，使用算符优先分析法也比较麻烦（一元运算的正负号和二元运算的加减号难以区分）；但如果完全使用递归子程序法也会造成困难（强行提取左公因子会出现很多没有实际意义的辅助非终结符）。所以这里对递归子程序法进行了一定的改进。

首先定义表达式接口 IExpr，继承语法单元接口 IUnit（定义了构建语法树的`build()`方法）。表达式类 Expr 和数字类 Number 均实现该接口（单个数字和复杂表达式均是表达式的一种）。Expr 类代表二元运算，具有属性：左表达式（IExpr）、运算符和右表达式（IExpr）。

随后定义 Expr 的三个子类：Term 代表表达式中的一项（包括所有的正负号，但不包括四则运算），MulExpr 代表乘法运算（每个因子都是一个 Term），AddExpr 代表加减运算（每个加数都是一个 MulExpr）。以上三个类的`build()`方法返回值均为 IExpr，而所需表达式本质上就是一个 AddExpr。

### 1.1 Term 的构建

项的开头字符只可能是`<Plus>`，`<Sub>`，`<Number>`或`<LPar>`。首先循环读入 token 直至出现非正负号的字符；将读入的连续正负号合并成最终的正负号。随后读入的字符如果是`<LPar>`，那么就递归构建一个 Expr（总之后面一定会是一个 IExpr）。如果符号为正，直接返回这个 IExpr，如果符号为负，则返回 0 减去这个 IExpr 的一个表达式。

### 1.2 MulExpr 的构建

首先构建一个 Term 作为左表达式；随后的字符如果是乘、除、取余运算，就进行循环：将当前的左右表达式合并到左表达式，再构建一个新的 Term 作为新的右表达式（因为是从左到右运算）；直至后面的字符不是乘、除或取余，完成构建。

### 1.3 AddExpr 的构建

和 MulExpr 类似，但每次构建的都是一个 MulExpr 而不是 Term，循环直至加减运算结束。



## 2. 中间代码的生成

IExpr 接口定义了`calculate()`方法，递归调用就可以计算得到表达式的值。但为方便拓展，将每个运算步骤都转换为中间变量。按照二叉树的先序遍历顺序，将所有的 Expr 节点标号（Number 不需要标号，直接嵌入中间代码）：每个 Expr 节点在其左右子节点标号完成后将自己也标号，随后输出一行中间代码。最终`ret`的就是表达式树的根 IExpr 节点的编号代表的中间变量。

