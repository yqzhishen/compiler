# Lab 8 实验报告

#### 姓名：杨迁		学号：19231120



Lab 8 的主要内容是实现自定义函数。由于之前已经做过函数调用，所以在语法分析方面都没有什么难度，生成中间代码的部分难点主要是集中在数组作为形式参数的实现上。

### 形参的处理

由于采用数字编号，所以每个形参都需要占用一个编号。例如带有两个参数的函数，形参分别编号为`%0`和`%1`，第一个基本块的标签（通常省略）编号为`%2`，因此函数体内编号要从`%3`开始。在生成函数的中间代码时，要先将形参压入符号栈（这些形参位于全局变量之上的一层，和函数体同层）。然后要为形参分配空间，因为形参也是变量，在函数体内部可能会改变它们的值：

```c
void foo(int a) {
    a = 1; // useless but correct
}
```

所以就要将传入函数的参数值存到内存里，例如对于上面的函数，应该生成这样的中间代码：

```ir
define dso_local void @foo(i32 %0) {
    %2 = alloca i32
    store i32 %0, i32* %2
    store i32 1, i32* %2
    ret void
}
```

还有一类形参是数组，其本质上是指针，由于数组是不可以直接赋值的（只能对数组元素进行操作），所以不需要为它们分配空间。例如这样的函数：

```c
int foo(int a[]) {
    return a[0];
}
```

直接生成这样的中间代码即可，不需要为形参数组`a`分配空间。

```ir
define dso_local i32 @foo(i32* %0) {
    %2 = getelementptr i32, i32* %0, i32 0
    %3 = load i32, i32* %2
    ret i32 %3
}
```

形参数组和函数内直接定义的局部数组处理逻辑是有区别的，因为本质上来讲形参数组属于指针（例如`i32*`），而直接定义的局部数组则是真正的数组（例如`[5 x i32]`）。这就导致了对它们不能使用相同的`getelementptr`指令。例如对于一个`[5 x i32]`的数组，获取第二个元素的方式：

```ir
%ele = getelementptr [5 x i32], [5 x i32]* %arr, i32 0, i32 1
```

但对于形参数组`int a[]`而言，它本身已经是指针类型（`i32*`），相当于是少了一级，对它取第一维下标相当于指针的偏移而非数组元素的下标，所以方法是这样的：

```ir
%ele = getelementptr i32, i32* %arr, i32 1
```

所以形参数组元素的访问和赋值与本函数内直接定义的局部数组的区别就在于`getelementptr`指令中的那个 0。对这一点进行特别判断，其余地方两种数组用法相同。

### 实参的处理

当数组整个作为实参传递时，也要针对这个数组是否是形参指针（有可能是形参被传递到了下一级调用中）进行不同的处理。如果是指针就直接传递，否则需要取头部：

```ir
%head = getelementptr [5 x i32], [5 x i32]* %arr, i32 0, i32 0
```

后面的操作数是两个 0，这样相当于把数组的第一维转换成了指针。

对于数组的一部分作为实参传递时，要在`getelementptr`的最后多加一个`i32 0`。例如`int a[5][4]`取`a[2]`：

```ir
%res = getelementptr [5 x [4 x i32]], [5 x [4 x i32]]* @a, i32 0, i32 2, i32 0
```

其实上面这个指令相当于取了元素`a[2][0]`的地址，但我们可以把它作为代表`a[2]`的指针传递给被调用函数。
